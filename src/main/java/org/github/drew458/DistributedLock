package org.github.drew458;

import org.springframework.lang.NonNull;

import java.io.Closeable;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.List;

/**
 * The ASCII encoding works as follows:
 * Each ASCII char is 7 bits allowing for 9 chars = 63 bits in total.
 * In order to differentiate between different-length strings with leading '\0',
 * we additionally fill the next bit after the string ends with 0. We then fill any
 * remaining bits with 1. Therefore, the final 64 bit value is 0-9 7-bit characters followed by 0,
 * followed by N=63-(7*length) 1s
 */
public class DistributedLock implements AutoCloseable {

    @Autowired
    protected JdbcTemplate jdbcTemplate;

    private static final int ASCII_CHAR_BITS = 7;
    private static final int MAX_ASCII_VALUE = (1 << ASCII_CHAR_BITS) - 1;
    private static final int MAX_ASCII_LENGTH = (8 * Long.BYTES) / ASCII_CHAR_BITS;

    private static final char HASH_STRING_SEPARATOR = ',';
    private static final int HASH_PART_LENGTH = 8, // 8-byte hex numbers
            HASH_STRING_LENGTH = 16, // 2 hashes
            SEPARATED_HASH_STRING_LENGTH = HASH_STRING_LENGTH + 1; // separated by comma

    public void lock() {
        switch (this.lockType) {
            case SESSION_LOCK -> jdbcTemplate.query(Utils.buildLockQuery(false, true, this.isSingleKey(), this.isShared), rs -> null, getSQLParams());
            case TRANSACTION_LOCK -> jdbcTemplate.query(Utils.buildLockQuery(false, false, this.isSingleKey(), this.isShared), rs -> null, getSQLParams());
        }
    }

    public Boolean tryLock() {
        return switch (this.lockType) {
            case SESSION_LOCK ->
                    jdbcTemplate.queryForObject(Utils.buildLockQuery(true, true, this.isSingleKey(), this.isShared), Boolean.class, getSQLParams());
            case TRANSACTION_LOCK ->
                    jdbcTemplate.queryForObject(Utils.buildLockQuery(true, false, this.isSingleKey(), this.isShared), Boolean.class, getSQLParams());
        };
    }

    /**
     * Releases a previously-acquired exclusive session-level distributedLock.
     * If the distributedLock was not held by the current session the method will still return normally.
     */
    public void unlock() {
        jdbcTemplate.queryForObject(Utils.buildUnlockQuery(this.isSingleKey(), this.isShared), Boolean.class, getSQLParams());
    }

    /**
     * Releases all session-level advisory locks held by the current session.
     */
    public void unlockAll() {
        jdbcTemplate.query("SELECT pg_catalog.pg_advisory_unlock_all()", rse -> null);
    }

    /**
     * Queries if this lock is held by any session.
     * This method is designed for use in monitoring of the system state, not for synchronization control.
     *
     * @param lock An instantiated lock
     * @return true if any session holds this lock and false otherwise
     */
    public Boolean isLocked() {
        return jdbcTemplate.queryForObject("SELECT EXISTS ( " +
                        "SELECT objid FROM pg_catalog.pg_locks WHERE locktype = 'advisory' AND CAST(objid AS bigint) = ?" +
                        ")",
                Boolean.class, this.getKey());
    }

    /**
     * Retrieves all the distributed locks currently held in the database by any session.
     *
     * @return A list of Locks
     */
    public List<DistributedLock> getAllLocks() {
        return jdbcTemplate.query("SELECT CAST(objid AS bigint) FROM pg_catalog.pg_locks WHERE locktype = 'advisory'",
                (rs, rowNum) -> new DistributedLock(rs.getLong(1)));
    }

    /**
     * Closes this resource, relinquishing any underlying resources.
     * This method is invoked automatically on objects managed by the
     * {@code try}-with-resources statement.
     *
     * @throws Exception if this resource cannot be closed
     * @apiNote While this interface method is declared to throw {@code
     * Exception}, implementers are <em>strongly</em> encouraged to
     * declare concrete implementations of the {@code close} method to
     * throw more specific exceptions, or to throw no exception at all
     * if the close operation cannot fail.
     *
     * <p> Cases where the close operation may fail require careful
     * attention by implementers. It is strongly advised to relinquish
     * the underlying resources and to internally <em>mark</em> the
     * resource as closed, prior to throwing the exception. The {@code
     * close} method is unlikely to be invoked more than once and so
     * this ensures that the resources are released in a timely manner.
     * Furthermore it reduces problems that could arise when the resource
     * wraps, or is wrapped, by another resource.
     *
     * <p><em>Implementers of this interface are also strongly advised
     * to not have the {@code close} method throw {@link
     * InterruptedException}.</em>
     * <p>
     * This exception interacts with a thread's interrupted status,
     * and runtime misbehavior is likely to occur if an {@code
     * InterruptedException} is {@linkplain Throwable#addSuppressed
     * suppressed}.
     * <p>
     * More generally, if it would cause problems for an
     * exception to be suppressed, the {@code AutoCloseable.close}
     * method should not throw it.
     *
     * <p>Note that unlike the {@link Closeable#close close}
     * method of {@link Closeable}, this {@code close} method
     * is <em>not</em> required to be idempotent.  In other words,
     * calling this {@code close} method more than once may have some
     * visible side effect, unlike {@code Closeable.close} which is
     * required to have no effect if called more than once.
     * <p>
     * However, implementers of this interface are strongly encouraged
     * to make their {@code close} methods idempotent.
     */
    @Override
    public void close() throws Exception {
        this.unlock();
    }

    private enum KeyEncoding {
        INT_64,
        INT_32_PAIR,
        ASCII,
    }

    private long key;

    private LockType lockType = LockType.SESSION_LOCK;

    private boolean isShared = false;

    private KeyEncoding keyEncoding;

    private static boolean hasSeparator = false;

    /**
     * The default lock configuration is a mutual exclusive session lock.
     * @param key A 64 bit lock identifier
     */
    public DistributedLock(long key) {
        this.key = key;
        this.keyEncoding = KeyEncoding.INT_64;
    }

    /**
     *
     * @param key A 64 bit lock identifier
     * @param isShared A shared lock does not conflict with other shared locks on the same resource, only with exclusive locks.
     */
    public DistributedLock(long key, boolean isShared) {
        this.key = key;
        this.keyEncoding = KeyEncoding.INT_64;
        this.isShared = isShared;
    }

    /**
     * @param key A 64 bit lock identifier
     * @param lockType Specifies if is Session level or Transaction level
     */
    public DistributedLock(long key, LockType lockType) {
        this.key = key;
        this.keyEncoding = KeyEncoding.INT_64;
        this.lockType = lockType;
    }

    /**
     * @param key A 64 bit lock identifier
     * @param lockType Specifies if is Session level or Transaction level
     * @param isShared A shared lock does not conflict with other shared locks on the same resource, only with exclusive locks.
     */
    public DistributedLock(long key, LockType lockType, boolean isShared) {
        this.key = key;
        this.keyEncoding = KeyEncoding.INT_64;
        this.lockType = lockType;
        this.isShared = isShared;
    }

    /**
     * @param key1 A 32-bit integer
     * @param key2 A 32-bit integer
     */
    public DistributedLock(int key1, int key2) {
        this.key = combineKeys(key1, key2);
        this.keyEncoding = KeyEncoding.INT_32_PAIR;
    }

    /**
     * @param key1 A 32-bit integer
     * @param key2 A 32-bit integer
     * @param isShared A shared lock does not conflict with other shared locks on the same resource, only with exclusive locks.
     */
    public DistributedLock(int key1, int key2, boolean isShared) {
        this.key = combineKeys(key1, key2);
        this.keyEncoding = KeyEncoding.INT_32_PAIR;
        this.isShared = isShared;
    }

    /**
     * @param key1 A 32-bit integer
     * @param key2 A 32-bit integer
     * @param lockType Specifies if is Session level or Transaction level
     */
    public DistributedLock(int key1, int key2, LockType lockType) {
        this.key = combineKeys(key1, key2);
        this.keyEncoding = KeyEncoding.INT_32_PAIR;
        this.lockType = lockType;
    }

    /**
     * @param key1 A 32-bit integer
     * @param key2 A 32-bit integer
     * @param lockType Specifies if is Session level or Transaction level
     * @param isShared A shared lock does not conflict with other shared locks on the same resource, only with exclusive locks.
     */
    public DistributedLock(int key1, int key2, LockType lockType, boolean isShared) {
        this.key = combineKeys(key1, key2);
        this.keyEncoding = KeyEncoding.INT_32_PAIR;
        this.lockType = lockType;
        this.isShared = isShared;
    }

    /**
     * Constructs a key based on a string as a key.
     * <p>
     * If the string is of the form 16-digit hex or (8-digit hex, 8-digit hex), this will be parsed into numeric keys.
     * <p>
     * If the string is an ascii string with 9 or fewer characters, it will be mapped to a key that does not collide with
     * any other key based on such a string or based on a 32-bit value.
     * <p>
     * Other string names will be rejected unless "allowHashing" is specified, in which case it will be hashed to
     * a 64-bit key value.
     *
     * @param name         The lock key
     * @param allowHashing if True, the string will be hashed if other methods fail
     */
    public DistributedLock(@NonNull String name, boolean allowHashing) throws Exception {

        try {
            this.key = tryEncodeAscii(name);
            this.keyEncoding = KeyEncoding.ASCII;

        } catch (Exception e) {

            try {
                this.key = tryEncodeHashString(name);
                this.keyEncoding = hasSeparator ? KeyEncoding.INT_32_PAIR : KeyEncoding.INT_64;

            } catch (Exception ex) {
                if (allowHashing) {
                    try {
                        this.key = hashString(name);
                        this.keyEncoding = KeyEncoding.INT_64;

                    } catch (Exception exc) {

                        throw new Exception(
                                String.format(
                                        "Name '%s' could not be encoded. Please specify allowHashing or use one of the following formats: " +
                                                "(1) a 0-%s character string using only ASCII characters, " +
                                                "(2) a %s character hex string, such as the result of %s, " +
                                                "(3) a 2-part, %s character string of the form XXXXXXXX%sXXXXXXXX, where the X's are %s hex strings " +
                                                "such as the result of %s). " +
                                                "Note that each unique string provided for formats 1 and 2 will map to a unique hash value," +
                                                "with no collisions across formats. Format 3 strings use the same key space as 2.",
                                        name, MAX_ASCII_LENGTH, HASH_STRING_LENGTH, Integer.MAX_VALUE,
                                        SEPARATED_HASH_STRING_LENGTH, HASH_STRING_SEPARATOR, HASH_PART_LENGTH, HASH_PART_LENGTH)
                        );
                    }
                }
            }
        }
    }

    private static long tryEncodeAscii(String name) throws Exception {

        if (name.length() > MAX_ASCII_LENGTH) {
            throw new Exception("Name is longer than 73, the maximum characters allowed");
        }

        // load the chars into result
        var result = 0L;
        for (var character : name.toCharArray()) {
            if (character > MAX_ASCII_VALUE) {
                throw new Exception("Character value is bigger than the maximum value allowed of 127");
            }

            result = (result << ASCII_CHAR_BITS) | character;
        }

        // add padding
        result <<= 1; // load zero
        for (var i = name.length(); i < MAX_ASCII_LENGTH; ++i) {
            result = (result << ASCII_CHAR_BITS) | MAX_ASCII_VALUE; // load 1s
        }

        return result;
    }

    private static long tryEncodeHashString(String name) throws Exception {

        if (name.length() == SEPARATED_HASH_STRING_LENGTH && name.toCharArray()[HASH_PART_LENGTH] == HASH_STRING_SEPARATOR) {
            hasSeparator = true;
        } else {
            hasSeparator = false;

            if (name.length() != HASH_STRING_LENGTH) {
                throw new Exception();
            }
        }

        return tryParseHashKeys(name);
    }

    private static long tryParseHashKeys(String text) {

        var key1 = Integer.parseInt(text.substring(0, HASH_PART_LENGTH), 16);
        var key2 = Integer.parseInt(text.substring(text.length() - HASH_PART_LENGTH), 16);
        return combineKeys(key1, key2);
    }

    private static long combineKeys(Integer key1, Integer key2) {
        return (long) key1 << (8 * Integer.BYTES / 8) | (key2 & 0xFFFFFFFFL);
    }

    private static List<Integer> splitKey(Long key) {
        return List.of(
                (int) (key >> (8 * Integer.BYTES)),
                (int) (key & Integer.MAX_VALUE)
        );
    }

    /**
     * The hash result from SHA1 is too large, so we have to truncate (recommended practice and does not
     * weaken the hash other than due to using fewer bytes)
     *
     * @param name The string to hash
     * @return The hashed string as long
     */
    private static long hashString(String name) throws NoSuchAlgorithmException {

        var md = MessageDigest.getInstance("SHA-1");
        var hashBytes = md.digest(name.getBytes(StandardCharsets.UTF_8));

        // We don't use BitConverter here because we want to be endianess-agnostic.
        // However, this code replicates that result on little-endian
        var result = 0L;
        for (var i = Long.BYTES - 1; i >= 0; --i) {
            result = (result << 8) | hashBytes[i];
        }
        return result;
    }

    public boolean isSingleKey() {
        return keyEncoding == KeyEncoding.INT_64;
    }

    public long getKey() {
        return key;
    }

    public List<Integer> getKeys() {
        return splitKey(key);
    }

    public void setKey(long key) {
        this.key = key;
    }

    public LockType getLockType() {
        return lockType;
    }

    public void setLockType(LockType lockType) {
        this.lockType = lockType;
    }

    public boolean getShared() {
        return this.isShared;
    }

    public void setShared(boolean isShared) {
        this.isShared = isShared;
    }

    private Object[] getSQLParams() {
        Object[] params;

        if (this.isSingleKey()) {
            params = new Object[]{this.getKey()};
        } else {
            var keys = this.getKeys();
            params = new Object[]{keys.get(0), keys.get(1)};
        }

        return params;
    }
}
